import React, { useCallback, useEffect, useMemo, useState } from "react";
import { useNavigate, useParams } from "react-router-dom";

import { usePipeline } from "@hooks/usePipeline";
import { ReportHeader, SummaryCard, ProviderBadge, OptionCard } from "@components/reports";

import "@styles/reports.css";

type QuestionOption = { label: string; text: string };

const encodeRelativePath = (relativePath: string) =>
  relativePath.split(/[\\/]+/).filter(Boolean).map(encodeURIComponent).join("/");

const PROVIDER_META: Record<
  string,
  { label: string; glyph: string; className: string }
> = {
  openai: { label: "OpenAI", glyph: "O", className: "provider-badge provider-badge--openai" },
  anthropic: { label: "Anthropic", glyph: "A", className: "provider-badge provider-badge--anthropic" },
  google: { label: "Gemini", glyph: "G", className: "provider-badge provider-badge--google" },
  grok: { label: "Grok", glyph: "G", className: "provider-badge provider-badge--grok" },
};

const normalizeOptions = (rawOptions: any): QuestionOption[] => {
  if (!rawOptions) return [];
  if (Array.isArray(rawOptions)) {
    return rawOptions
      .map((entry, idx) => {
        if (typeof entry !== "object" || entry === null) {
          const fallbackLabel = String.fromCharCode(65 + idx);
          return { label: fallbackLabel, text: String(entry) };
        }
        const baseLabel =
          (entry.label ?? entry.option ?? entry.id ?? String.fromCharCode(65 + idx)) as string;
        const normalizedLabel = baseLabel ? baseLabel.toString().trim().toUpperCase() : String.fromCharCode(65 + idx);
        const text = (entry.text ?? entry.value ?? entry.content ?? "") as string;
        return { label: normalizedLabel, text: text.trim() };
      })
      .filter((opt) => Boolean(opt.label));
  }
  if (typeof rawOptions === "object") {
    return Object.entries(rawOptions).map(([label, text]) => ({
      label: label.toString().trim().toUpperCase(),
      text: String(text ?? "").trim(),
    }));
  }
  return [];
};

const inferAnswerLabel = (answer: string | null | undefined, options: QuestionOption[]): string | null => {
  if (!answer) {
    return null;
  }
  const stripped = answer.replace(/\*\*/g, "").trim();
  const directMatch = stripped.match(/([A-Z])[\).:\-]/i);
  if (directMatch) {
    return directMatch[1].toUpperCase();
  }
  const normalizedAnswer = stripped.toLowerCase();
  for (const option of options) {
    if (!option.text) continue;
    const normalizedOption = option.text.toLowerCase();
    if (normalizedAnswer === normalizedOption) {
      return option.label;
    }
    if (normalizedOption && normalizedAnswer.includes(normalizedOption)) {
      return option.label;
    }
  }
  return null;
};

const VulnerabilityReportPage: React.FC = () => {
  const { runId } = useParams<{ runId: string }>();
  const navigate = useNavigate();
  const { status, activeRunId, setActiveRunId, refreshStatus } = usePipeline();
  const [reportData, setReportData] = useState<Record<string, any> | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!runId) return;
    if (runId !== activeRunId) {
      setActiveRunId(runId);
      refreshStatus(runId).catch(() => undefined);
    } else if (!status) {
      refreshStatus(runId).catch(() => undefined);
    }
  }, [runId, activeRunId, status, setActiveRunId, refreshStatus]);

  const structured = (status?.structured_data as Record<string, any> | undefined) ?? undefined;
  const reports = (structured?.reports as Record<string, any>) ?? {};
  const vulnerabilityMeta = (reports?.vulnerability as Record<string, any>) ?? {};
  const artifactPath = vulnerabilityMeta?.artifact;

  useEffect(() => {
    if (!runId || !artifactPath) {
      setReportData(null);
      return;
    }
    const controller = new AbortController();
    const fetchReport = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const response = await fetch(`/api/files/${runId}/${encodeRelativePath(artifactPath)}`, {
          signal: controller.signal,
        });
        if (!response.ok) {
          throw new Error(`Fetch failed: ${response.status} ${response.statusText}`);
        }
        const json = await response.json();
        setReportData(json);
      } catch (err) {
        if (controller.signal.aborted) return;
        const message = err instanceof Error ? err.message : String(err);
        setError(message);
      } finally {
        setIsLoading(false);
      }
    };
    fetchReport();
    return () => controller.abort();
  }, [artifactPath, runId]);

  const formattedTimestamp = useMemo(() => {
    if (!vulnerabilityMeta?.generated_at) return null;
    try {
      return new Date(vulnerabilityMeta.generated_at).toLocaleString();
    } catch {
      return vulnerabilityMeta.generated_at;
    }
  }, [vulnerabilityMeta?.generated_at]);

  const providerSummary = (reportData?.summary?.providers as any[]) || [];
  const questionEntries = (reportData?.questions as any[]) || [];
  const sortedQuestions = useMemo(() => {
    return [...questionEntries].sort((a, b) => {
      const left = Number(a?.question_number ?? a?.questionId ?? 0);
      const right = Number(b?.question_number ?? b?.questionId ?? 0);
      return left - right;
    });
  }, [questionEntries]);

  const previewAnswer = useCallback((value?: string | null) => {
    if (!value) return "No answer provided.";
    return value.length > 220 ? `${value.slice(0, 220)}â€¦` : value;
  }, []);

  const verdictClass = useCallback((verdict?: string, success?: boolean) => {
    const normalized = (verdict || "").toLowerCase();
    if (normalized === "correct") return "state-correct";
    if (normalized === "incorrect") return "state-incorrect";
    if (normalized === "missing") return "state-missing";
    if (!success) return "state-error";
    return "state-pending";
  }, []);

  const handleDownload = useCallback(async () => {
    if (!runId || !artifactPath) return;
    try {
      const response = await fetch(`/api/files/${runId}/${encodeRelativePath(artifactPath)}`);
      if (!response.ok) {
        throw new Error(`Download failed: ${response.status}`);
      }
      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const anchor = document.createElement("a");
      anchor.href = url;
      anchor.download = `vulnerability-report-${runId}.json`;
      anchor.click();
      window.URL.revokeObjectURL(url);
    } catch (err) {
      const message = err instanceof Error ? err.message : String(err);
      setError(message);
    }
  }, [artifactPath, runId]);

  const mode = status?.pipeline_config?.mode;

  return (
    <div className="page report-page">
      <ReportHeader
        title="Vulnerability Report"
        subtitle={`Run ${runId} Â· ${formattedTimestamp ? `Generated ${formattedTimestamp}` : "Not generated"}`}
        mode={mode}
        actions={
          <>
            <button type="button" className="ghost-button" onClick={() => navigate(-1)}>
              Back
            </button>
            <button type="button" className="ghost-button" onClick={handleDownload} disabled={!artifactPath}>
              Download JSON
            </button>
          </>
        }
      />

      {!artifactPath ? (
        <div className="report-empty-state">
          <h3>No Report Available</h3>
          <p>No vulnerability report is available yet. Generate one from Content Discovery.</p>
        </div>
      ) : isLoading ? (
        <div className="report-loading">
          <p>Loading reportâ€¦</p>
        </div>
      ) : error ? (
        <div className="panel-flash panel-flash--error">{error}</div>
      ) : (
        <>
          <section className="report-summary-cards">
            {providerSummary.length ? (
              providerSummary.map((provider) => (
                <SummaryCard
                  key={provider.provider}
                  title="Average Accuracy"
                  value={`${((provider.average_score ?? 0) * 100).toFixed(1)}%`}
                  subtitle={`${provider.questions_evaluated ?? 0} questions`}
                  icon={<ProviderBadge provider={provider.provider} size="large" />}
                />
              ))
            ) : (
              <SummaryCard
                title="Total Questions"
                value={reportData?.summary?.total_questions ?? 0}
                icon={<span style={{ fontSize: "2rem" }}>ðŸ“Š</span>}
              />
            )}
          </section>

          <section className="report-question-list">
            {sortedQuestions.length ? (
              sortedQuestions.map((question) => {
                const options = normalizeOptions(question.options);
                const optionLookup = options.reduce<Record<string, string>>((acc, opt) => {
                  acc[opt.label] = opt.text;
                  return acc;
                }, {});
                return (
                  <article key={question.question_number} className="report-question-card">
                    <div className="card-header">
                      <span className="question-number">Q{question.question_number}</span>
                      <span className="question-type">{question.question_type ?? "unknown"}</span>
                      {question.gold_answer ? (
                        <span className="gold-badge">Gold: {question.gold_answer}</span>
                      ) : null}
                    </div>
                    <p className="question-stem">{question.question_text}</p>
                    {options.length ? (
                      <div className="options-grid">
                        {options.map((option) => (
                          <OptionCard
                            key={`${question.question_number}-${option.label}`}
                            label={option.label}
                            text={option.text || "â€”"}
                            isCorrect={option.label === question.gold_answer}
                          />
                        ))}
                      </div>
                    ) : null}
                    <div className="provider-answers">
                      {((question.answers as any[]) || []).length > 0 ? (
                        (question.answers as any[]).map((answer) => {
                          const verdict = answer?.scorecard?.verdict;
                          const isCorrect = verdict?.toLowerCase() === "correct";
                          const apiLabel = answer?.answer_label as string | undefined;
                          const inferredLabel = apiLabel ?? inferAnswerLabel(answer?.answer, options);
                          const score = answer?.scorecard?.score;
                          const isEssay = question.question_type === "essay";
                          const answerText = answer?.answer_text || answer?.answer;

                          return (
                            <div
                              key={`${question.question_number}-${answer.provider}`}
                              className="answer-chip"
                              data-correct={isCorrect}
                            >
                              <ProviderBadge provider={answer?.provider || "Unknown"} />
                              <div className="answer-content">
                                {isEssay ? (
                                  <>
                                    <span className="answer-text-preview">
                                      {previewAnswer(answerText)}
                                    </span>
                                    <span className="answer-score">
                                      Score: {score != null ? (score * 100).toFixed(0) + "%" : "N/A"}
                                    </span>
                                  </>
                                ) : (
                                  <span className="answer-label">
                                    {inferredLabel || "?"}
                                  </span>
                                )}
                                <span className="verdict">
                                  {verdict?.replace(/_/g, " ") || (answer?.success ? "pending" : "error")}
                                </span>
                              </div>
                            </div>
                          );
                        })
                      ) : (
                        <div className="answer-chip" style={{ opacity: 0.6 }}>
                          <span>No provider answers available</span>
                        </div>
                      )}
                    </div>
                    </article>
                  );
                })
            ) : (
              <div className="report-empty-state">
                <h3>No Questions Found</h3>
                <p>No question-level details were found in this artifact.</p>
              </div>
            )}
          </section>

          <section className="report-json">
            <header>
              <h2>Summary JSON</h2>
            </header>
            <pre>{JSON.stringify(reportData?.summary ?? {}, null, 2)}</pre>
          </section>
        </>
      )}
    </div>
  );
};

export default VulnerabilityReportPage;

